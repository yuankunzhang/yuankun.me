<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Yuankun's Blog</title><meta name="description" content="A Blog Powered By Hexo"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><link rel="search" type="application/opensearchdescription+xml" href="https://yuankun.me/atom.xml" title="Yuankun's Blog"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link active">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/yuankunzhang" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><ul class="home post-list"><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2017/09/22/brew-cleanup/" class="post-title-link">别忘了定期执行 brew cleanup 哦</a></h2><div class="post-info">Sep 22, 2017</div><div class="post-content"><p>使用 Homebrew 进行包管理的朋友们注意了，Homebrew 不会自动移除旧版本的软件包，你需要手动执行 <code>brew cleanup</code> 命令才可以。</p>
<p>如果你从来没调用过这个命令，那么它帮你释放出来的磁盘空间可能会吓到你。可以看看 Stackoverflow 上的<a href="https://superuser.com/questions/975701/how-can-i-remove-outdated-installed-versions-of-homebrew-packages" target="_blank" rel="external">这个回答</a>，大家在调用这个命令之后纷纷表示惊呆了，有个人甚至释放掉了 17.2GB 的磙盘占用。</p>
<p>另外，如果嫌麻烦的话，可以按下面的方式添加命令别名。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">alias brewski='brew update &amp;&amp; brew upgrade &amp;&amp; brew cleanup; brew doctor'</div><div class="line"></div><div class="line"><span class="meta">#</span> 针对 Fish Shell 的命令：</div><div class="line">abbr -a brewski 'brew update; and brew upgrade; and brew cleanup; and brew doctor'</div></pre></td></tr></table></figure></div><a href="/2017/09/22/brew-cleanup/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2017/08/21/list-running-process-environment-variables/" class="post-title-link">检视进程的环境变量</a></h2><div class="post-info">Aug 21, 2017</div><div class="post-content"><p>使用 <code>env</code> 命令可以查看系统当前的环境变量。有时候我们希望能够查看一个处在运行状态的进程的环境变量。</p>
<p>在 Linux 系统下面，进程的环境变量信息可以通过 <code>/proc/&lt;pid&gt;/environ</code> 文件查看：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> cat /proc/&lt;pid&gt;/environ</div></pre></td></tr></table></figure>
<p>该命令的输出格式不太容易读，所有的信息挤在了同一行。使用 <code>tr</code> 命令将空字符替换为换行符，将会使所有的环境变量按行显示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> cat /proc/&lt;pid&gt;/environ | tr \\0 \\n</div></pre></td></tr></table></figure>
<p>在 Mac OSX 系统下面，可以使用下面的命令，其中的 <code>-E</code> 选项表示打印进程的环境变量：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> ps -p &lt;pid&gt; -wwwE</div></pre></td></tr></table></figure></div><a href="/2017/08/21/list-running-process-environment-variables/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2017/08/11/introduction-to-tsdb/" class="post-title-link">认识时序数据库</a></h2><div class="post-info">Aug 11, 2017</div><div class="post-content"><p>在很多场景下，数据并不是孤立的存在。例如股票价格的走势，一天之内温度的变化等。一组相关数据以时间为坐标串联起来，形成一条连续的变化线，这就是时序数据。时序数据可以直观地反映变化的规律性，也可以方便地用来识别和预测异常情形。</p>
<p>而时序数据库，就是专门用来存储时序数据的一类特殊数据库。</p>
<p>相比于传统的 RDBMS 或者 NoSQL，时序数据库有下列鲜明的特征。</p></div><a href="/2017/08/11/introduction-to-tsdb/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2017/08/06/enable-https-with-lets-encrypt/" class="post-title-link">使用 Let's Encrypt 为网站启用 HTTPS 支持</a></h2><div class="post-info">Aug 6, 2017</div><div class="post-content"><p>HTTP 协议传输的数据都是不加密的。想象一下，你访问某个网站，当数据经过路由器、宽带网关，以及某墙的时候都是完全可见的，是不是有种裸奔的感觉？为网站启用 HTTPS 支持可以说是大势所趋，在某国日益倒车的互联网环境下更是如此。</p>
<p>第零步是选择一个靠谱的 CA（Certificate Authority，数字证书认证中心）。你以为所有的认证中心都是中立可信的吗？并不是的，比如此前频频爆出丑闻的 WoSign 和 StarCom，这两家认证中心<a href="https://security.googleblog.com/2016/10/distrusting-wosign-and-startcom.html" target="_blank" rel="external">已经被 Google Chrome 等多款浏览器默认设置为不信任</a>。当然你更不能自己做裁判，像 12306.cn 一样给自己颁发证书。这里推荐 <a href="https://letsencrypt.org/" target="_blank" rel="external">Let’s Encrypt</a>，这家成立于 2016 年、由互联网安全研究小组（ISRG）主导的机构致力于向用户提供<strong>免费的、自动化管理</strong>的证书方案。</p></div><a href="/2017/08/06/enable-https-with-lets-encrypt/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2017/07/30/add-http-basic-auth-to-prometheus/" class="post-title-link">为 Prometheus 添加 HTTP Basic Auth</a></h2><div class="post-info">Jul 30, 2017</div><div class="post-content"><p>Prometheus 的 <a href="https://github.com/prometheus/node_exporter" target="_blank" rel="external">Node Exporter</a> 并没有提供任何认证支持。不过，借助 Nginx 作为反向代理服务器，我们可以很容易地为 Node Exporter 添加 HTTP Basic Auth 功能。</p>
<p>首先，启动 Node Exporter，监听 9090 端口。</p>
<p>然后，在 <code>/etc/nginx</code> （可能你的 Nginx 配置目录在其他路径，请做相应修改）目录下，使用 <code>apache2-utils</code> 提供的 <code>htpasswd</code> 工具创建一个用户文件，需要填入用户名和密码：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> htpasswd -c .htpasswd yuankun</div><div class="line">New password: </div><div class="line">Re-type new password: </div><div class="line">Adding password for user yuankun</div></pre></td></tr></table></figure></div><a href="/2017/07/30/add-http-basic-auth-to-prometheus/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2017/05/03/plan-storage-space-for-prometheus/" class="post-title-link">规划 Prometheus 的存储用量</a></h2><div class="post-info">May 3, 2017</div><div class="post-content"><h2 id="一-引言"><a href="#一-引言" class="headerlink" title="一. 引言"></a>一. 引言</h2><p><a href="https://prometheus.io/" target="_blank" rel="external">Prometheus</a> 是一款开源的监控与报警系统，支持对海量监控数据的抓取与查询。在部署 Prometheus 服务之前，对服务的存储用量进行规划是十分重要的。否则，运维人员无法对业务数据的规模和所需存储资源的量级获得直观认识。分配的存储资源过多，会导致资源闲置与成本浪费；分配的存储容量不足，则无法应对业务的增长，严重影响监控服务的稳定性。</p>
<p>部署 Prometheus 服务的第一个步骤是，整理与获得需要监控的节点集合。通过这一集合，我们可以计算出业务数据的规模。进而，我们可以计算出，需要多少存储资源来支撑监控服务的运行。</p>
<p>本文对影响 Prometheus 服务的运行时存储用量的各个因素进行了剖析与讨论，并给出若干经验公式。这些公式可以用于预估监控服务的内存和硬盘用量。</p></div><a href="/2017/05/03/plan-storage-space-for-prometheus/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2017/02/03/trap-in-euclids-proof-of-primes/" class="post-title-link">隐藏在素数无穷的证明中的一个陷阱</a></h2><div class="post-info">Feb 3, 2017</div><div class="post-content"><p>我们知道，关于素数有无穷多个的最普遍的证明方法是欧几里得的反证法：</p>
<blockquote>
<p>假设存在最大的素数 P，那么我们可以基于所有的素数构造一个新的数 $Q = 2 \times 3 \times 5 \times 7 \times … \times P + 1$。显然这个数不能被任一素数整除（所有素数除它都余1），这说明我们找到了一个更大的素数。</p>
</blockquote>
<p>我发现很多人误认为我们构造的这个新数 Q 是一个素数（甚至有些数学教材上也这么写），这其实是不对的。基于 Q 不能被任意素数整除这一事实，我们无法推断 Q 是否为素数，仅能够得到下面的结论：Q 或者是一个素数，或者包含一个比最大的素数 P 更大的素数因子。</p>
<p>通过简单的几行程序就能找到”存在 Q 为合数“的证据。这个数并不大。当 P 为 13 时，$Q = 2 \times 3 \times 5 \times 7 \times 11 \times 13 +1 = 30031 = 59 \times 509$。</p></div><a href="/2017/02/03/trap-in-euclids-proof-of-primes/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2017/02/02/my-bucket-list/" class="post-title-link">我的遗愿清单</a></h2><div class="post-info">Feb 2, 2017</div><div class="post-content"><p>在这个春节我要为自己写一篇遗愿清单。</p>
<p>新年伊始就谈及死亡这么沉重的话题，似乎不合时宜。恰恰相反，我把这篇遗愿清单当作是送给我自己的新年礼物。每个人都会死，不过很少有年轻人认真地考虑过这个事情。他们自然地认为还有很长时间要活，因此经常会做一件极其愚蠢的事情：尽力打法时间。</p>
<p>假如你的一生仅仅剩下一个月，一周，或者一天，你会做些什么呢？只有接受了“终究会死”这一现实，你才会更加严肃地对待余下的生命，更加清晰地认识到对自己而言真正重要的事情是什么。</p></div><a href="/2017/02/02/my-bucket-list/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/08/22/the-feynman-technique/" class="post-title-link">费恩曼学习法</a></h2><div class="post-info">Aug 22, 2016</div><div class="post-content"><p>我们在学习知识的时候，不仅要做到知其然，更要做到知其所以然。有些时候，你觉得自己完全搞懂了某个问题，可是在向其他人讲解的时候，却结结巴巴讲不出来。这并不是表达能力的问题，而是你压根就没搞懂。著名的诺贝尔奖获得者理查德·费恩曼先生有一套自己的学习方法，这套方法施行起来极其简单，但效果却出奇地惊人（如果你能坚持使用的话）。下面就是费恩曼学习法的四个步骤。</p></div><a href="/2016/08/22/the-feynman-technique/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/02/29/reading-notes-on-programmers-at-work/" class="post-title-link">聆听大师们的声音 - 《编程大师访谈录》读后</a></h2><div class="post-info">Feb 29, 2016</div><div class="post-content"><blockquote>
<p>可以说，执行特定任务就像是从大杂烩中选定菜目，排出一席美味佳肴。你可以左手一份美味右手一盘佳肴，但搁在一起可能味同狗粮。懂得巧妙搭配食材才称得上好厨师。同样，把程序各个部分妥善组合在一起，才是成就优秀计算机程序员之道。</p>
<p>– 《编程大师访谈录》</p>
</blockquote>
<p>这个周末，我花了两天时间读完了《编程大师访谈录》。书中收录了对19个传奇程序员的访谈内容，其中不乏大师们对编程的严肃思考和深刻洞见，读来趣味盎然。本文摘录了一组具有代表性的问答，从中可以对大师们对待编程的认识和想法管窥一斑。</p>
<p>请注意，大师们的见解与论断未必全盘正确，不加思考地把他们的观点拿来奉为圭臬是危险的。本书的迷人之处在于，大师们的那些充满冒险性与创造性的想法可以给我们带来深刻的启发。循着这些启发做一番自己的思考，或可得到一二真知。</p>
<p>另外，本书的成书时间是1986年。阅读时，需要把访谈置于当时的环境背景之下，方能透过时空和这些大师进行对话。</p></div><a href="/2016/02/29/reading-notes-on-programmers-at-work/" class="read-more">...more</a></article></li></ul></main><footer><div class="paginator"><a href="/page/2/" class="next">NEXT</a></div><div class="copyright"><p>© 2017 <a href="https://yuankun.me">Yuankun Zhang</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]} });</script><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-104475777-1",'auto');ga('send','pageview');</script></body></html>